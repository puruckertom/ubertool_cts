"""
CTS workflow/module-oriented REST endpoints

For Chemical Editor, p-chem table, chemical speciation,
and reaction pathways.
"""

import logging
import requests
import json
from django.http import HttpResponse, HttpRequest
from django.template.loader import render_to_string
from django.shortcuts import render_to_response


from chemaxon_cts import jchem_rest
from smilesfilter import filterSMILES
from models.chemspec import chemspec_output


# TODO: Consider putting these classes somewhere else, maybe even the *_models.py files!
class Molecule(object):
	"""
	Basic molecule object for CTS
	"""

	def __init__(self):

		# cts keys:
		self.chemical = ''  # initial structure from user (any chemaxon format)
		self.orig_smiles = ''  # before filtering, converted to smiles

		# chemaxon/jchem keys:
		self.smiles = ''  # post filtered smiles 
		self.formula = ''
		self.iupac = ''
		self.mass = ''
		self.structureData = ''

	def createMolecule(self, chemical, orig_smiles, chem_details_response):
		"""
		Gets Molecule attributes from jchem_rest getChemDetails response
		"""
		try:
			# set attrs from jchem data:
			for key in self.__dict__.keys():
				if key != 'orig_smiles' and key != 'chemical':
					self.__setattr__(key, chem_details_response['data'][0][key])
			# set cts attrs:
			self.__setattr__('chemical', chemical)
			self.__setattr__('orig_smiles', orig_smiles)

			return self.__dict__
		except KeyError as err:
			raise err


class CTS_REST(object):
	"""
	CTS level endpoints for REST API.
	Will have subclasses for calculators and
	other CTS features, like metabolizer.
	"""
	def __init__(self):
		self.cts_meta_info = {
			'metaInfo': {
				'model': "cts",
				'collection': "qed",
				'modelVersion': "1.3.7",
				'description': "The Chemical Transformation System (CTS) was generated by researchers at the U.S. Enivornmental Protection Agency to provide access to a collection of physicochemical properties and reaction transformation pathways.",
				'status': '',
				'timestamp': jchem_rest.gen_jid(),
				'url': {
					'type': "application/json",
					'href': "https://qed.epa.gov/rest/cts"
				}
			},
		}

	def getCTSREST(self):
		"""
		Returns json for /rest/cts endpoint
		(GET)
		"""
		self.cts_meta_info['links'] = [
			{
				'rel': "episuite",
				'type': "application/json",
				'href': "https://qed.epa.gov/rest/cts/episuite"
			},
			{
				'rel': "chemaxon",
				'type': "application/json",
				'href': "https://qed.epa.gov/rest/cts/chemaxon"
			},
			{
				'rel': "sparc",
				'type': "application/json",
				'href': "https://qed.epa.gov/rest/cts/sparc"
			},
			{
				'rel': "test",
				'type': "application/json",
				'href': "https://qed.epa.gov/rest/cts/test"
			},
			{
				'rel': "metabolizer",
				'type': "application/json",
				'href': "https://qed.epa.gov/rest/cts/metabolizer"
			}
		]
		return HttpResponse(json.dumps(self.cts_meta_info), content_type='application/json')


class Chemaxon_CTS_REST(CTS_REST):
	"""
	CTS REST endpoints, etc. for ChemAxon
	"""
	def __init__(self):
		self.chemaxon_meta_info = {
			'metaInfo': {
				'model': "chemaxon",
				'collection': "qed",
				'modelVersion': "Jchem Web Services 15.3.23.0",
				'description': "Cheminformatics software platforms, applications, and services to optimize the value of chemistry information in life science and other R&D.",
				'status': '',
				'timestamp': jchem_rest.gen_jid(),
				'url': {
					'type': "application/json",
					'href': "https://qed.epa.gov/rest/cts/chemaxon"
				}
			}
		}

	def getChemaxonREST(self):
		"""
		List chemaxon endpoints
		"""
		self.chemaxon_meta_info['links'] = [
			{
				'rel': "inputs",
				'type': "application/json",
				'href': "https://qed.epa.gov/rest/cts/chemaxon/inputs",
				'description': "ChemAxon input schema"
			},
			{
				'rel': "outputs",
				'type': "application/json",
				'href': "https://qed.epa.gov/rest/cts/chemaxon/outputs",
				'description': "ChemAxon output schema"
			},
			{
				'rel': "run",
				'type': "application/json",
				'href': "https://qed.epa.gov/rest/cts/chemaxon/run",
				'description': "ChemAxon estimated values"
			}

		]
		return HttpResponse(json.dumps(self.chemaxon_meta_info), content_type="application/json")

	def getChemaxonInputs(self, request):
		response = self.chemaxon_meta_info

		# Below is chemspec workflow's inputs:
		# response.update({
		# 	'inputs': {
		# 		'chem_struct': 'aspirin',
		# 		'smiles': 'CC(=O)OC1=CC=CC=C1C(O)=O',
		# 		'orig_smiles': 'CC(=O)OC1=CC=CC=C1C(O)=O',
		# 		'name': '2-(acetyloxy)benzoic acid',
		# 		'formula': 'C9H8O4',
		# 		'mass': '180.159',
		# 		'get_pka': True,
		# 		'get_taut': False,
		# 		'get_stereo': False,
		# 		'pKa_decimals': '2',
		# 		'pKa_pH_lower': '0',
		# 		'pKa_pH_upper': '14',
		# 		'pKa_pH_increment': '0.2',
		# 		'pH_microspecies': '7.0',
		# 		'isoelectricPoint_pH_increment': '0.5',
		# 		'tautomer_maxNoOfStructures': '100',
		# 		'tautomer_pH': '7.0',
		# 		'stereoisomers_maxNoOfStructure': '100'
		# 	}
		# })

		chemical = request.POST.get('chemical')

		# get molecular info and append to inputs object:
		mol_info_response = json.loads(getChemicalEditorData(request).content)

		response.update({
			'inputs': {
				'chemical': '',
				'prop': '',
				'method': '',
				'ph': '',
				# 'node': '',
				'calc': "chemaxon",
				'run_type': "rest",
			}
		})

		return HttpResponse(json.dumps(response), content_type="application/json")


def showSwaggerPage(request):
	"""
	display swagger.json with swagger UI
	for CTS API docs/endpoints
	"""
	return render_to_response('swagger_index.html')


def getChemicalEditorData(request):
	"""
	Makes call to jchem_rest for chemaxon
	data. Converts incoming structure to smiles,
	then filters smiles, and then retrieves data
	:param request:
	:return: chemical details response json
	"""
	try:
		chemical = request.POST.get('chemical')

		request = requests.Request(data={'chemical': chemical})
		response = jchem_rest.convertToSMILES(request)  # convert chemical to smiles
		response = json.loads(response.content)  # get json data

		logging.warning("Converted SMILES: {}".format(response))

		orig_smiles = response['structure']

		filtered_smiles = filterSMILES(orig_smiles)  # call CTS REST SMILES filter

		logging.warning("Filtered SMILES: {}".format(filtered_smiles))

		request.data = {'chemical': filtered_smiles}
		jchem_response = jchem_rest.getChemDetails(request)  # get chemical details
		jchem_response = json.loads(jchem_response.content)

		# return this data in a standardized way for molecular info!!!!
		molecule_obj = Molecule().createMolecule(chemical, orig_smiles, jchem_response)

		wrapped_post = {
			'status': True,  # 'metadata': '',
			'data': molecule_obj
		}
		json_data = json.dumps(wrapped_post)

		return HttpResponse(json_data, content_type='application/json')

	except KeyError as error:
		logging.warning(error)
		wrapped_post = {
			'status': False, 
			'error': 'Error validating chemical',
			'chemical': chemical
		}
		return HttpResponse(json.dumps(wrapped_post), content_type='application/json')
	except Exception as error:
		logging.warning(error)
		wrapped_post = {'status': False, 'error': error}
		return HttpResponse(json.dumps(wrapped_post), content_type='application/json')


# class Metabolite(Molecule):


def getChemicalSpeciationData(request):
	"""
	CTS web service endpoint for getting
	chemical speciation data through  the
	chemspec model/class
	:param request - chemspec_model
	:return: chemical speciation data response json
	"""

	try:

		chemspec_obj = chemspec_output.chemspecOutputPage(request)

		wrapped_post = {
			'status': True,  # 'metadata': '',
			'data': chemspec_obj.run_data
		}
		json_data = json.dumps(wrapped_post)

		return HttpResponse(json_data, content_type='application/json')

	except Exception as error:
		raise


def booleanize(value):
	"""
    django checkbox comes back as 'on' or 'off',
    or True/False depending on version, so this
    makes sure they're True/False
    """
	if value == 'on' or value == 'true':
		return True
	if value == 'off' or value == 'false':
		return False
	if isinstance(value, bool):
		return value