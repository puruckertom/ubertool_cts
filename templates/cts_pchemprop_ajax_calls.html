<script type="text/javascript">

var kowPH; // pH for logD
var smiles, name, mass, formula, time;

var sparcPropMap = {
    "water_sol" : "SOLUBILITY",
    "vapor_press" : "VAPOR_PRESSURE",
    "mol_diss" : "WATER_DIFFUSION",
    "ion_con": "FULL_SPECIATION",
    "henrys_law_con" : "HENRYS_CONSTANT",
    "kow_no_ph" : "DISTRIBUTION",
    "kow_wph" : "LOGD",
    "boiling_point": "BOILING_POINT"
};


var checkedCalcsAndProps; // format --> {'calc': ['checked_prop', ..], ..}

$(document).ready(function() {

    checkedCalcsAndProps = {{checkedCalcsAndProps}};
    var structure = "{{structure}}";
    kowPH = "{{kow_ph}}";
    smiles = "{{structure}}";
    name = "{{name}}";
    mass = "{{mass}}";
    formula = "{{formula}}";
    time = "{{time}}";

    sparcPropMap['kow_ph'] = kowPH;

    startPchemPropDataCollection(structure, checkedCalcsAndProps, kowPH, null);

});


function startPchemPropDataCollection(structure, checkedCalcsAndProps, kowPH, node) {
    
    var ws = ""; // web service to direct to (jchem or test et al.)
    var calcPropData = {};
    if (checkedCalcsAndProps == null) {
        return;
    } 

    for (var calc in checkedCalcsAndProps) {
        if (checkedCalcsAndProps.hasOwnProperty(calc)) {

            if ( calc == "sparc" ) {
                // send all properties to back

                var props_list = [];
                for (var index in checkedCalcsAndProps["sparc"]) {
                    if (checkedCalcsAndProps["sparc"].hasOwnProperty(index)) {
                        props_list.push(checkedCalcsAndProps["sparc"][index]);
                    }
                }

                var post_data = {"chemical": structure, "calc": calc, "props": props_list};
                post_data.ws = "sparc";
                makeTheCall(post_data, node, true);
            }
            else {
                // loops through calculator's properties
                for (var i = 0; i < checkedCalcsAndProps[calc].length; i++) {

                    var prop = checkedCalcsAndProps[calc][i];
                    calcPropData = {"chemical": structure, "calc": calc, "prop": prop};

                    if (calc == "chemaxon") {
                        calcPropData.ws = "jchem";
                        calcPropData.service = "getPchemProps";
                        if (prop == "kow_wph") {
                            calcPropData.ph = kowPH;
                        }
                    }
                    else if (calc == "epi" || calc == "test") {
                        calcPropData.ws = calc;
                    }

                    var pchemForSelectedNode = parseFloat($('#gen-select-pchem').val());
                    var workflowPath = window.location.href;

                    if (workflowPath.indexOf("pchem") > -1 || pchemForSelectedNode == 0) {
                        var tblCell = $('.' + calc + '.' + prop);
                        $(tblCell).html('<img src="/static/images/loader.gif" id="spinner" />');
                        makeTheCall(calcPropData, node, true);
                    }
                    else {
                        // blockUI code (getting pchemprops for multiple metabolites)
                        // variable to keep track of displaying to pchem table or not
                        makeTheCall(calcPropData, node, false); // get data for > 1 metabolite
                    }

                    //makeTheCall(url, calcPropData, node, plotDataToTable);

                }
            }
        }
    }

}


function makeTheCall(calcPropData, node, plotDataToTable) {
    $.ajax({ 
        url: "/cts/portal",
        type: "POST",
        dataType: "json",
        data: calcPropData,
        timeout: 20000,
        // tryCount: 0,
        // retryLimit: 3,
        success: function(data) {
            // console.log(this.tryCount);
            // console.log(this.retryLimit);
            if (data['calc'] == "sparc") {
                // sparc returns all props in json
                // parseSPARCResponseToPchemTable(data, plotDataToTable)
                parseSPARCResponseToPchemTable(data, node, plotDataToTable)
            }
            else {
                parseResponseToPchemTable(data, node, false, plotDataToTable);
            }
        },
        error: function(jqXHR, textStatus, errorThrown) {
            console.log(errorThrown);
            var error = {
                "error": textStatus,
                "calc": calcPropData['calc'],
                "prop": calcPropData['prop']
            };
            parseResponseToPchemTable(error, null, false, plotDataToTable);
        }
    });
}


function parseSPARCResponseToPchemTable(data, node, plotDataToTable) {
    var calc = data['calc']; // sparc
    var props = data['props']; // get sparc props list
    var sparc_results = data['data']['calculationResults'];
    console.log("parsing sparc data...");
    for (prop in props) {
        if (props.hasOwnProperty(prop)) {
            // var sparcPropName = sparcPropMap[props[prop]];
            console.log("current property: " + props[prop]);
            getPropFromSPARCResults(data, node, props[prop], sparc_results, plotDataToTable);
        }
    }
    console.log("finished..");
}


function getPropFromSPARCResults(data, node, prop, sparc_results, plotDataToTable) {
    var responseObj = {"calc": "sparc"}; // initial obj for parsing to table
    var sparcProp = sparcPropMap[prop]; // get sparc's name for prop

    console.log("parsing sparc results for property...");
    console.log("sparc property: " + sparcProp);

    for (index in sparc_results) {
        if (sparc_results.hasOwnProperty(index)) {
            var propObj = sparc_results[index]; // property object

            console.log("sparc property: ");
            console.log(propObj);

            if (propObj['type'] == sparcProp) {

                console.log("requested property found in sparc results...parsing to table...");

                responseObj['prop'] = prop;
                responseObj['data'] = propObj['result']; // prop result value

                parseResponseToPchemTable(responseObj, node, false, true, plotDataToTable);

                console.log("allegedly parsed to table...");

            }
        }
    }
}


function parseResponseToPchemTable(response, node, hasData, plotDataToTable) {
    //map response to pchemprop output table:

    var calc = response['calc'];
    var prop = response['prop'];

    if (response.hasOwnProperty('error')) {
        $('.' + calc + '.' + prop).html(response['error']); //add error to table
        console.log(response['error']);
        return; //get out of there
    }

    var data;
    if (response.hasOwnProperty('data')) {
        // if ((calc != "chemaxon") && (calc != "sparc")) {
        if (calc == "test") {
            // var test = response['data']['properties'].keys().length;
            if (response['data']['properties'] === "undefined") {
                data = "calc returned nothing";
                console.log("data has null value");
            }
            else if (response['data'].hasOwnProperty('error')) {
                data = "calc error";
                console.log(response['data']['error']);
            }
            else {
                // data = response['data']['val'];
                // var data_key = Object.keys(response['data']['properties']);
                data = response['data'];
            }
        }
        else if (calc == "epi") {
            // data = response['val']; // the old way
            var test = Object.keys(response['data']['properties']).length;
            if (Object.keys(response['data']['properties']).length > 0) {
                var data_key = Object.keys(response['data']['properties'])[0];
                data = response['data']['properties'][data_key];
            }
            else {
                data = "calc error";
            }
        }
        else {
            data = response['data'];
        }
    }

    var workflowUrl = window.location.href;
    if (workflowUrl.indexOf("pchem") > -1) {
        // at the pchemprop workflow, simply display data:
        $('.' + calc + '.' + prop).html(organizeData(data, prop)); //add data to table
    }
    else {
        if (node !== 'undefined' && node != null) {
            if (!node.data.hasOwnProperty('pchemprops')) {
                node.data.pchemprops = []; //array of with keys: calc, prop, data (single-level)
            }

            if (hasData == false) {
                node.data.pchemprops.push({"calc": calc, "prop": prop, "data": data});
            }

            if (plotDataToTable && currentNode) {
                $('.' + calc + '.' + prop).html(organizeData(data, prop)); //add data to table
            }

        }
    }
}


function organizeData(data, prop) {
    // organizes data, namely if it's
    // more than a single value

    if (typeof data === "number") {
        if (prop == "water_sol" || prop == "vapor_press" || prop == "mol_diss" || prop == "henrys_law_con") {
            return data.toExponential(3);
        }
        else {
            return data.toFixed(3);
        }
    }

    if (typeof data === "string" || data == null) {
        return data;
    }

    var parsedData = "";
    for (item in data) {
        if (data.hasOwnProperty(item) && data[item] != null) {
            var itemVals = data[item];
            if (itemVals.length == 0) {
                parsedData += '<div class="pka-wrapper">' + item + ': none</div>';
            }
            else {
                for (var i = 0; i < itemVals.length; i++) {
                    var label = item + String(i).sub() +  ': ';
                    parsedData += '<div class="pka-wrapper">' + label + itemVals[i].toFixed(3) + '</div>';
                }
            }
        }
    }
    return parsedData;
}

</script>