<script type="text/javascript">

var kowPH; // pH for logD
var smiles, name, mass, formula, time;

// var sparcPropMap = {
//     "water_sol" : "SOLUBILITY",
//     "vapor_press" : "VAPOR_PRESSURE",
//     "mol_diss" : "WATER_DIFFUSION",
//     "ion_con": "FULL_SPECIATION",
//     "henrys_law_con" : "HENRYS_CONSTANT",
//     "kow_no_ph" : "DISTRIBUTION",
//     "kow_wph" : "LOGD",
//     "boiling_point": "BOILING_POINT"
// };

var jchem_methods = ['KLOP', 'PHYS', 'VG'];
var checkedCalcsAndProps, structure; // format --> {'calc': ['checked_prop', ..], ..}
var spinner_html = '<img src="/static/images/loader.gif" id="spinner" />';
var calls_tracker = 0;  // keeps track of pchem data calls for metabolites
var total_calls = 0;  // used for metabolite pchem data progress
var socket = null; // web socket global var
var node_tracker = null;
var addDataToTable_tracker = null;
var batch_data = [];  // list of data for csv, incoming responses
var batch_chems = [];  // list of batch chemicals with molecular info
var workflow;
var run_type;

$(document).ready(function() {
    // Some global and local variable delcarations:
    checkedCalcsAndProps = {{checkedCalcsAndProps}};
    structure = "{{structure}}";
    kowPH = "{{kow_ph}}";
    smiles = "{{structure}}";
    name = "{{name}}";
    mass = "{{mass}}";
    formula = "{{formula}}";
    time = "{{time}}";
    workflow = "{{workflow}}";
    // nodes = "{{nodes}}";  // defaults to ""
    batch_chems = {{nodes}};
    run_type = "{{run_type}}";

    // sparcPropMap['kow_ph'] = kowPH;

    connectToSocket();

    if (batch_chems != null) {



        startPchemPropDataCollection(structure, checkedCalcsAndProps, kowPH, null, null, batch_chems);

        // calls_tracker = batch_chems.length;
        calls_tracker = calculateTotalCalls([batch_chems.length], checkedCalcsAndProps);
        total_calls = calls_tracker;

        // block UI with progress bar
        blockInterface(true);

        $('#pdfExport, #htmlExport').hide();


    }
    else {
        startPchemPropDataCollection(structure, checkedCalcsAndProps, kowPH, null, null);
    }

    // Get Data button (pchem workflow) for gathering pchem props:
    $('#btn-pchem-data').on('click', function() {
        if (socket) {
            socket.disconnect();
        }
        checkedCalcsAndProps = buildCheckedCalcsAndProps(); // from scripts_pchemprop.js
        kowPH = $('#id_kow_ph').val();
        connectToSocket();
        startPchemPropDataCollection(structure, checkedCalcsAndProps, kowPH, null, null);
    });

    // TODO: Cancel button, which removes pending tasks from celery queues:
    $('#btn-pchem-cancel').on('click', function () {
        console.log("pchem cancel button selected");
        socket.emit('get_data', JSON.stringify({'cancel': true, 'pchem_request': checkedCalcsAndProps}));
        blockInterface(false);
    });

});


function buildCheckedCalcsAndProps () {
    // front end way to get checkedCalcsAndProps without
    // calling cts-jchem rest
    var calc_data_obj = {};

    $('input.calc_checkbox:checked').each(function () {
        var calc_name = $(this).attr('name'); 
        var available_props = $('td.ChemCalcs_available.' + calc_name); // tbl cells of calc's available props..
        var calc_prop_checkboxes = $(available_props).parent().find('input[type=checkbox]');

        calc_data_obj[calc_name] = [];

        $(calc_prop_checkboxes).each(function () {
            if ($(this).is(':checked')) {
                var prop_name = this.name;
                calc_data_obj[calc_name].push(prop_name); 
            }
        });
    });
    return calc_data_obj;
}


function connectToSocket() {

    if (typeof io !== 'undefined') {
        // socket = io.connect("localhost", {port: 4000, 'force new connection': true});
        socket = io.connect('http://134.67.114.1', {'force new connection': true});
    }
    else {
        socket = null;
        return;
    }

    // incoming data pushed to client from redis:
    socket.on('message', function(data) {
        // calls_tracker--;
        // console.log("calls tracker: " + calls_tracker);
        
        data = JSON.parse(data);

        if ('status' in data) {
            // either display in requested table cells, or popup message:
            alert(data.status);  // display status to user
            // $('#pchemprop_table td').not('td.colorKey, th').html('');  // clear p-chem table
            return;
        }


        // expecting node object for gentrans workflow:
        // this conditional may ALWAYS be true! should be !=
        if (data['node'] != null) {

            // if (data.node.data.id === node_tracker.data.id) {
            if (currentNode != null && data.node.id === currentNode.id) {
                node_tracker = data.node;
                // parseResponseToPchemTable(data, node_tracker, false, true);
                if ('props' in data) {
                    parseListDataFromResults(data, node_tracker, addDataToTable_tracker);
                }
                else {
                    parseResponseToPchemTable(data, node_tracker, false, addDataToTable_tracker); // expecting prop data object as usual
                }
            }

            // add pchem data to node from graph:
            // if (!('run_type' in data)) {
            //     addPchemDataToNode(data['node'], data);  // cts_gentrans_tree
            // }
            if (window.location.href.indexOf('batch') > -1) {

                if (workflow == 'gentrans') {

                    // walk through n-nested results...
                    // or do this on the backend, maybe
                    // refactoring data_walks, or adding a 
                    // new function..

                    init(data.data);
                    st_array.push(st);  // add spacetree instance to array
                    // nodeList = addGenKey($jit.json, data.data);

                    var products = st.graph.nodes;
                    var product_data = [];
                    for (product in products) {

                        var product_gen = parseFloat(products[product]['data']['generation']);

                        if (product_gen <= genMax) {
                            product_data.push(products[product]['data']);
                        }
                    }

                    batch_data.push(product_data);

                }
                else {
                    batch_data.push(data);
                }

            }

            calls_tracker--;
            console.log("calls tracker: " + calls_tracker);

            if (calls_tracker <= 0) {
                console.log("All data retrieved!");
                blockInterface(false);

                // if batch, display link for CSV:
                if (window.location.href.indexOf('batch') > -1) {

                    // link.innerHTML = "<h3> Export to CSV </h3>";
                    // document.body.appendChild(link);
                    // $('div.articles_output').append(link);

                    // var link = '<a id="csv_batch"><h3> Export batch results to CSV </h3></a>';

                    // $('div.articles_output').append(link);  

                    $('#export_menu').css('position', 'relative');
                    $('#export_menu').prepend('<h3>Batch results ready for download</h3>');                  

                }

            }
            else {
                updateProgressBar(calls_tracker, total_calls);
            }

            // return;
        }

        parseResponseToPchemTable(data, data['node'], false, addDataToTable_tracker);

        // if ('props' in data) {
        //     parseListDataFromResults(data, node_tracker, addDataToTable_tracker);
        // }
        // else {
        //     parseResponseToPchemTable(data, node_tracker, false, addDataToTable_tracker); // expecting prop data object as usual
        // }
    });
}


function startPchemPropDataCollection(structure, checkedCalcsAndProps, kowPH, node, currentNode, nodes) {
    
    if (checkedCalcsAndProps == null) { return; }

    // var num_pchem = parseFloat($('#gen-select-pchem').val()); // number of props
    var addDataToTable = false; // whether to plot on visible pchem table or not..

    // Determine whether data should be inserted into pchem table:
    if (isPchemWorkflow() && window.location.href.indexOf('batch') < 0) { 
        addDataToTable = true;
    }
    else if (currentNode != null && node.id == currentNode.id) { 
        addDataToTable = true;
    }
    else { 
        addDataToTable = false;
    }

    node_tracker = node;
    addDataToTable_tracker = addDataToTable;

    var pchem_data = {};

    var pchem_data = {
        'chemical': structure,
        'ph': kowPH,
        'node': node,
        'pchem_request': checkedCalcsAndProps
    };


    // adding new nodes stuff:
    if (nodes != null) {
        pchem_data['nodes'] = nodes;  // add nodes key (list of nodes)
    }

    if (run_type != null) {
        pchem_data['run_type'] = run_type
    }

    if (workflow == 'gentrans') {
        pchem_data['service'] = 'getTransProducts';
        pchem_data['calc'] = 'chemaxon';
        pchem_data['workflow'] = 'gentrans';
    }

    // pchem_data['calc'] = calc;
    // pchem_data['props'] = checkedCalcsAndProps[calc];  // get list of requested props

    // var pchem_data_json = JSON.stringify(pchem_data);
    var cache = [];
    var pchem_data_json = JSON.stringify(pchem_data, function(key, value) {
        if (typeof value === 'object' && value !== null) {
            if (cache.indexOf(value) !== -1) {
                // Circular reference found, discard key
                return;
            }
            // Store value in our collection
            cache.push(value);
        }
        return value;
    });
    cache = null; // Enable garbage collection

    if (socket) {
        // emit data through web socket:
        socket.emit('get_data', pchem_data_json)
    }
    else {
        // send pchem request through ajax calls, one calc per call:
        makeTheCall(pchem_data_json, node, addDataToTable);
    }

    // adds spinners to table cells
    // todo: do this a better way!
    for (var calc in checkedCalcsAndProps) {
        for (var i = 0; i < checkedCalcsAndProps[calc].length; i++) {
            var prop = checkedCalcsAndProps[calc][i]; // p-chem property..
            var tblCell = $('.' + calc + '.' + prop); // table cell for spinner..
            if (addDataToTable) { $(tblCell).html(spinner_html); }
        }
    }

}


function makeTheCall(calcPropData, node, addDataToTable) {
    calls_tracker++;
    console.log("calls tracker: " + calls_tracker);
    $.ajax({
        url: "/cts/portal",
        type: "POST",
        dataType: "json",
        data: calcPropData,
        success: function(data) {
            calls_tracker--;
            if (node) { updateProgressBar(calls_tracker, total_calls); }
            console.log("calls tracker: " + calls_tracker);
            if (node) { $("#" + node.id).children('img').addClass("hasPchemProps"); } // highlight node..
            if ('props' in data) {
                parseListDataFromResults(data, node, addDataToTable);
            }
            else {
                parseResponseToPchemTable(data, node, false, addDataToTable);
            }
        },
        error: function(jqXHR, textStatus, errorThrown) {
            console.log("Error: " + errorThrown);
            calls_tracker--; // TODO (maybe): retry call instead of decrementing and moving on..
            if (node) { updateProgressBar(calls_tracker, total_calls); }
            var error = {
                "error": textStatus,
                "calc": calcPropData['calc'],
                "prop": calcPropData['prop']
            };
            if ('props' in calcPropData) {
                parseListDataFromResults(error, node, addDataToTable);
            }
            else {
                parseResponseToPchemTable(error, node, false, addDataToTable);
            }
        }
    });
}


function parseListDataFromResults(data, node, addDataToTable) {
    var calc = data['calc']; // sparc
    var props = data['props']; // get sparc props list
    var data_key = "";
    if ('error' in data) {
        for (prop in props) {
            var prop_obj = {'calc': data['calc'], 'prop': prop, 'data': data['error']};
            parseResponseToPchemTable(prop_obj, node, false, addDataToTable);  // note: hasData hardcoded to false!!
        }
    }
    else { 
        for (prop_data in data['data']) {
            var prop_obj;
            if ('error' in data) { 
                prop_data = {'calc': data['calc'], 'prop': data['prop'], 'data': data['error']};
            }
            else { 
                prop_obj = data['data'][prop_data];
            }
            parseResponseToPchemTable(prop_obj, node, false, addDataToTable);  // note: hasData hardcoded to false!!
        }   
    }
}


function isPchemWorkflow() {
    var workflow_url = window.location.href;
    if (workflow_url.indexOf("pchem") > -1) { return true; }
    else { return false; }
}


function parseResponseToPchemTable(response, node, hasData, addDataToTable) {
    // Map response to pchemprop output table.
    // Every calc-prop data value comes here.

    // if (node) {
    //     calls_tracker--;
    //     console.log("calls tracker: " + calls_tracker);

    //     if (calls_tracker <= 0) {
    //         console.log("All data retrieved!");
    //         blockInterface(false);
    //     }
    // }

    var calc = response['calc'];
    var prop = response['prop'];
    var table_cell = $('.' + calc + '.' + prop); // table cell for calc's prop..
    var data;

    // TODO: improve error handling to mitigate error checking like below..
    if (response.hasOwnProperty('error')) { 
        // $(table_cell).html("");
        $(table_cell).html(response['error']);
        return;
    }

    else if (!('data' in response)) {
        $(table_cell.html("error processing data"));
        return;
    }
    else if (calc == "epi") {
        if (response.data.propertyvalue) {
            data = response.data.propertyvalue;
        }
        else {
            data = response['data'];
        }
    }
    else { data = response['data']; }

    // Add pchemprop data to node if gentrans workflow:
    if (!isPchemWorkflow()) {

        // get node object from spacetree:
        for (node_index in st.graph.nodes) {
            var some_node = st.graph.nodes[node_index];
            if (some_node.data.genKey == node.genKey) {
                node = some_node;
            }
        }

        if (!node.data.hasOwnProperty('pchemprops')) {
            node.data.pchemprops = []; // keys: calc, prop, data (single-level)..
        }
        var post_data = {"calc": calc, "prop": prop, "data": data};
        if (response.hasOwnProperty('method')) { 
            post_data['method'] = response['method'];
        }
        if (hasData == false) {
            node.data.pchemprops.push(post_data);
            // $('')
            addPchemDataToNode(node, post_data);
        }
    }

    if (response.hasOwnProperty('method')) {
        var method = response['method'];
        var has_spinner = $(table_cell).children('img#spinner').length;
        if (has_spinner > 0) { $(table_cell).html(""); }
        if (addDataToTable) {
            $(table_cell).append(organizeData(calc, prop, data) + " " + method + "<br>"); // append method to cell..
        }
    }
    else { 
        if (addDataToTable) { 
            $(table_cell).html(organizeData(calc, prop, data));
        }
    }

}


function organizeData(calc, prop, data) {
    // organizes data, namely if it's
    // more than a single value

    if (typeof data === "number") {
        if (prop == "water_sol" || prop == "vapor_press" || prop == "mol_diss" || prop == "henrys_law_con") {
            if (calc == "test" && prop == "vapor_press") { data = Math.pow(10, data); }
            return data.toExponential(2);
        }
        else {
            return data.toFixed(2);
        }
    }

    if (typeof data === "string" || data == null) {
        return data;
    }

    // For multiple pKa values in a cell..
    var parsedData = "";
    for (item in data) {
        if (data.hasOwnProperty(item) && data[item] != null) {
            var itemVals = data[item];
            if (itemVals.length == 0) {
                parsedData += '<div class="pka-wrapper">' + item + ': none</div>';
            }
            else {
                for (var i = 0; i < itemVals.length; i++) {
                    var label = item + String(i + 1).sub() +  ': ';
                    parsedData += '<div class="pka-wrapper">' + label + itemVals[i].toFixed(2) + '</div>';
                }
            }
        }
    }
    return parsedData;
}


function calculateTotalCalls(nodes_list, checkedCalcsAndProps) {
    // get max calls for progress bar (max metabolites + calcs + props + any methods):
    var num_nodes = 0;
    for (var i = 0; i < nodes_list.length; i++) {
        num_nodes += nodes_list[i];
    }

    var num_props = 0;
    for (calc in checkedCalcsAndProps) {
        if (checkedCalcsAndProps.hasOwnProperty(calc)) {
            var props = checkedCalcsAndProps[calc];
            for (var i = 0; i < props.length; i ++) {
                var prop = props[i];
                if (calc == "chemaxon") { 
                    if (prop == 'kow_no_ph' || prop == 'kow_wph') { 
                        num_props += 3;  // these chemaxon props have 3 methods
                    }
                    else { num_props += 1; }
                }
                else { num_props += 1; }
            }
        }
    }
    var total_calls = num_nodes * num_props;
    return total_calls;
}


function jsonRepack(jsonobj) {
  return JSON.parse(JSON.stringify(jsonobj));
}

</script>