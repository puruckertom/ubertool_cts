<script type="text/javascript">

var kowPH; // pH for logD
var smiles, name, mass, formula, time;

var sparcPropMap = {
    "water_sol" : "SOLUBILITY",
    "vapor_press" : "VAPOR_PRESSURE",
    "mol_diss" : "WATER_DIFFUSION",
    "ion_con": "FULL_SPECIATION",
    "henrys_law_con" : "HENRYS_CONSTANT",
    "kow_no_ph" : "DISTRIBUTION",
    "kow_wph" : "LOGD",
    "boiling_point": "BOILING_POINT"
};

var jchem_methods = ['KLOP', 'PHYS', 'VG'];
var checkedCalcsAndProps, structure; // format --> {'calc': ['checked_prop', ..], ..}
var spinner_html = '<img src="/static/images/loader.gif" id="spinner" />';
var calls_tracker = 0;  // keeps track of pchem data calls for metabolites
var total_calls = 0;  // used for metabolite pchem data progress
var socket = null; // web socket global var
var node_tracker = null;
var addDataToTable_tracker = null;

$(document).ready(function() {
    // Some global and local variable delcarations:
    checkedCalcsAndProps = {{checkedCalcsAndProps}};
    structure = "{{structure}}";
    kowPH = "{{kow_ph}}";
    smiles = "{{structure}}";
    name = "{{name}}";
    mass = "{{mass}}";
    formula = "{{formula}}";
    time = "{{time}}";
    sparcPropMap['kow_ph'] = kowPH;

    connectToSocket();
    startPchemPropDataCollection(structure, checkedCalcsAndProps, kowPH, null, null); // get pchem data..

    // Get Data button (pchem workflow) for gathering pchem props:
    $('#btn-pchem-data').on('click', function() {

        // quick check for kow ph range:
        if (socket) {
            socket.disconnect();
        }
        checkedCalcsAndProps = buildCheckedCalcsAndProps(); // from scripts_pchemprop.js
        kowPH = $('#id_kow_ph').val();
        connectToSocket();
        startPchemPropDataCollection(structure, checkedCalcsAndProps, kowPH, null, null);
    });

});


// {'calc1': ['prop1', 'prop2'], 'calc2': ['prop']}
function buildCheckedCalcsAndProps () {
    // front end way to get checkedCalcsAndProps without
    // calling cts-jchem rest
    var calc_data_obj = {};

    $('input.calc_checkbox:checked').each(function () {
        var calc_name = $(this).attr('name'); 
        var available_props = $('td.ChemCalcs_available.' + calc_name); // tbl cells of calc's available props..
        var calc_prop_checkboxes = $(available_props).parent().find('input[type=checkbox]');

        calc_data_obj[calc_name] = [];

        $(calc_prop_checkboxes).each(function () {
            if ($(this).is(':checked')) {
                var prop_name = this.name;
                calc_data_obj[calc_name].push(prop_name); 
            }
        });
    });
    return calc_data_obj;
}


function connectToSocket() {

    if (typeof io !== 'undefined') {
        socket = io.connect("localhost", {port: 4000, 'force new connection': true}); // initiates user connection on node server
    }
    else {
        socket = null;
        return;
    }

    // incoming data pushed to client from redis:
    socket.on('message', function(data) {
        // if (node) { $("#" + node.id).children('img').addClass("hasPchemProps"); } // highlight node
        data = JSON.parse(data);
        if ('props' in data) {
            parseListDataFromResults(data, node_tracker, addDataToTable_tracker);
        }
        else {
            parseResponseToPchemTable(data, node_tracker, false, addDataToTable_tracker); // expecting prop data object as usual
        }
    });
}


function startPchemPropDataCollection(structure, checkedCalcsAndProps, kowPH, node, currentNode) {
    
    if (checkedCalcsAndProps == null) { return; }

    var num_pchem = parseFloat($('#gen-select-pchem').val()); // number of props
    var addDataToTable = false; // whether to plot on visible pchem table or not..

    // Determine whether data should be inserted into pchem table:
    if (isPchemWorkflow()) { addDataToTable = true; }
    else if (currentNode != null && node.id == currentNode.id) { addDataToTable = true; }
    else { addDataToTable = false; }

    node_tracker = node;
    addDataToTable_tracker = addDataToTable;

    for (var calc in checkedCalcsAndProps) {

        var post_data = { "chemical": structure, "calc": calc };

        // 2. Add webservice key:
        if (calc == "chemaxon") { 
            post_data.ws = "jchem";
            post_data.service = "getPchemProps";
        }
        else { post_data.ws = calc; }

        for (var i = 0; i < checkedCalcsAndProps[calc].length; i++) {

            var prop = checkedCalcsAndProps[calc][i]; // p-chem property..
            var tblCell = $('.' + calc + '.' + prop); // table cell for spinner..

            // 3. Build POST data:
            post_data['prop'] = prop;
            post_data['ph'] = kowPH;

            // 4. Add spinner to calc-prop table cell:
            if (addDataToTable) { $(tblCell).html(spinner_html); }

            // 5. Make data calls, determine if additional methods required:
            if (calc == "chemaxon") {
                if (prop == "kow_wph" || prop == "kow_no_ph") {
                    for (var method in jchem_methods) {
                        post_data['method'] = jchem_methods[method];
                        makeTheCall(post_data, node, addDataToTable, socket);
                    }
                    delete post_data['method']; // lazy fix for methods showing in non-method props
                }
                else { 
                    makeTheCall(post_data, node, addDataToTable, socket);
                }
            }
            else if (calc == "epi") {
                makeTheCall(post_data, node, addDataToTable, socket);
            }
        }

        // Make sparc call after all props are gathered into list:
        if (calc == "sparc") { 
            post_data['props'] = checkedCalcsAndProps['sparc'];
            makeTheCall(post_data, node, addDataToTable, socket);
        }
        else if (calc == "test") {
            post_data['props'] = checkedCalcsAndProps['test'];
            makeTheCall(post_data, node, addDataToTable, socket);
        }

    }

}


function makeTheCall(calcPropData, node, addDataToTable, socket) {
    if (socket) {
        calcPropData['node'] = node; // send node through socket for tracking returned data
        var post_data = JSON.stringify(calcPropData);
        socket.emit('get_data', post_data);
    }
    else {
        calls_tracker++;
        console.log("calls tracker: " + calls_tracker);
        $.ajax({
            url: "/cts/portal",
            type: "POST",
            dataType: "json",
            data: calcPropData,
            success: function(data) {
                calls_tracker--;
                if (node) { updateProgressBar(calls_tracker, total_calls); }
                console.log("calls tracker: " + calls_tracker);
                if (node) { $("#" + node.id).children('img').addClass("hasPchemProps"); } // highlight node..
                if ('props' in data) {
                    parseListDataFromResults(data, node, addDataToTable);
                }
                else {
                    parseResponseToPchemTable(data, node, false, addDataToTable);
                }
            },
            error: function(jqXHR, textStatus, errorThrown) {
                console.log("Error: " + errorThrown);
                calls_tracker--; // TODO (maybe): retry call instead of decrementing and moving on..
                if (node) { updateProgressBar(calls_tracker, total_calls); }
                var error = {
                    "error": textStatus,
                    "calc": calcPropData['calc'],
                    "prop": calcPropData['prop']
                };
                if ('props' in calcPropData) {
                    parseListDataFromResults(error, node, addDataToTable);
                }
                else {
                    parseResponseToPchemTable(error, node, false, addDataToTable);
                }
            }
        });
    }
}


function parseListDataFromResults(data, node, addDataToTable) {
    var calc = data['calc']; // sparc
    var props = data['props']; // get sparc props list
    for (prop_data in data['data']) {
        var prop_obj;
        if ('error' in data) { 
            prop_data = {'calc': data['calc'], 'prop': data['prop'], 'data': data['error']};
        }
        else { 
            prop_obj = data['data'][prop_data];
        }
        parseResponseToPchemTable(prop_obj, node, false, true, addDataToTable);
    }
}


function isPchemWorkflow() {
    var workflow_url = window.location.href;
    if (workflow_url.indexOf("pchem") > -1) { return true; }
    else { return false; }
}


function parseResponseToPchemTable(response, node, hasData, addDataToTable) {
    // Map response to pchemprop output table:

    var calc = response['calc'];
    var prop = response['prop'];
    var table_cell = $('.' + calc + '.' + prop); // table cell for calc's prop..
    var data;

    // TODO: improve error handling to mitigate error checking like below..
    if (response.hasOwnProperty('error')) { 
        $(table_cell).html(response['error']);
        return;
    }

    else if (!('data' in response)) {
        $(table_cell.html("error processing data"));
        return;
    }

    if (calc == "test" || calc == "epi") {
        if (hasData) { data = response['data']; } // data already parsed from epi to node
        else {
            // data = response['data']['val']; // the old way..
            // the new way:
            if (Object.keys(response['data']['properties']).length > 0) {
                var data_key = Object.keys(response['data']['properties'])[0];
                data = response['data']['properties'][data_key];
            }
            else { data = "calc error"; }
        }    
    }
    else { data = response['data']; }

    // Add pchemprop data to node if gentrans workflow:
    if (!isPchemWorkflow()) {
        if (!node.data.hasOwnProperty('pchemprops')) {
            node.data.pchemprops = []; // keys: calc, prop, data (single-level)..
        }
        var post_data = {"calc": calc, "prop": prop, "data": data};
        if (response.hasOwnProperty('method')) { 
            post_data['method'] = response['method'];
        }
        if (hasData == false) {
            node.data.pchemprops.push(post_data);
        }
    }

    if (response.hasOwnProperty('method')) {
        var method = response['method'];
        var has_spinner = $(table_cell).children('img#spinner').length;
        if (has_spinner > 0) { $(table_cell).html(""); }
        if (addDataToTable) {
            $(table_cell).append(organizeData(calc, prop, data) + " (" + method + ")<br>"); // append method to cell..
        }
    }
    else { 
        if (addDataToTable) { $(table_cell).html(organizeData(calc, prop, data)); }
    }

}


function organizeData(calc, prop, data) {
    // organizes data, namely if it's
    // more than a single value

    if (typeof data === "number") {
        if (prop == "water_sol" || prop == "vapor_press" || prop == "mol_diss" || prop == "henrys_law_con") {
            if (calc == "test" && prop == "vapor_press") { data = Math.pow(10, data); }
            return data.toExponential(3);
        }
        else {
            return data.toFixed(3);
        }
    }

    if (typeof data === "string" || data == null) {
        return data;
    }

    // For multiple pKa values in a cell..
    var parsedData = "";
    for (item in data) {
        if (data.hasOwnProperty(item) && data[item] != null) {
            var itemVals = data[item];
            if (itemVals.length == 0) {
                parsedData += '<div class="pka-wrapper">' + item + ': none</div>';
            }
            else {
                for (var i = 0; i < itemVals.length; i++) {
                    var label = item + String(i).sub() +  ': ';
                    parsedData += '<div class="pka-wrapper">' + label + itemVals[i].toFixed(3) + '</div>';
                }
            }
        }
    }
    return parsedData;
}


function jsonRepack(jsonobj) {
  return JSON.parse(JSON.stringify(jsonobj));
}

</script>